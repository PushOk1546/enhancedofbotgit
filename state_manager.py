"""
–ú–µ–Ω–µ–¥–∂–µ—Ä —Å–æ—Å—Ç–æ—è–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.
–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.
–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –æ—Ç –∫–æ–º–∞–Ω–¥—ã —Å–µ–Ω—å–æ—Ä —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤:
- –ê—Ç–æ–º–∞—Ä–Ω–∞—è –∑–∞–ø–∏—Å—å –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∫–æ—Ä—Ä—É–ø—Ü–∏–∏
- –£–ª—É—á—à–µ–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é
- –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤–≤–æ–¥–∞/–≤—ã–≤–æ–¥–∞
- –ù–û–í–û–ï: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
"""

import json
import logging
import asyncio
import os
import tempfile
import shutil
import gc
import glob
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict, field

logger = logging.getLogger("bot_logger")

@dataclass
class UserPreferences:
    """–ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    content_types: List[str] = field(default_factory=list)
    price_range: str = "any"
    communication_style: str = "friendly"
    notification_frequency: str = "sometimes"
    completed_survey: bool = False

@dataclass
class UserState:
    """–°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    user_id: int
    model: str = "eco"
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    last_activity: str = field(default_factory=lambda: datetime.now().isoformat())
    preferences: UserPreferences = field(default_factory=UserPreferences)
    current_survey_step: Optional[str] = None
    waiting_for_reply: bool = False
    history: List[Dict[str, Any]] = field(default_factory=list)
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è —á–∞—Ç–æ–≤
    waiting_for_chat_name: bool = False
    waiting_for_chat_reply: bool = False
    chat_manager = None
    
    # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –°—Ç—Ä–æ–≥–∏–µ –ª–∏–º–∏—Ç—ã –¥–ª—è memory management
    MAX_HISTORY_SIZE = 50
    MAX_CONTENT_LENGTH = 4000  # üÜï –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –¥–≤—É—è–∑—ã—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (EN + RU)
    
    def to_dict(self) -> Dict[str, Any]:
        """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏"""
        data = asdict(self)
        data['preferences'] = asdict(self.preferences)
        
        # –°–µ—Ä–∏–∞–ª–∏–∑—É–µ–º chat_manager –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
        if self.chat_manager is not None:
            data['chat_manager'] = self.chat_manager.to_dict()
        else:
            data['chat_manager'] = None
            
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'UserState':
        """–°–æ–∑–¥–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ —Å–ª–æ–≤–∞—Ä—è"""
        preferences_data = data.pop('preferences', {})
        preferences = UserPreferences(**preferences_data)
        
        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º chat_manager –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
        chat_manager_data = data.pop('chat_manager', None)
        
        user_state = cls(
            preferences=preferences,
            **data
        )
        
        # –°–æ–∑–¥–∞–µ–º ChatManager –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
        if chat_manager_data is not None:
            from chat_models import ChatManager
            user_state.chat_manager = ChatManager.from_dict(chat_manager_data)
        else:
            user_state.chat_manager = None
            
        return user_state
    
    def add_message_to_history(self, role: str, content: str):
        """
        –î–æ–±–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ö–æ–Ω—Ç—Ä–æ–ª—å –ø–∞–º—è—Ç–∏ –∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞.
        """
        # –û–±—Ä–µ–∑–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏
        truncated_content = content[:self.MAX_CONTENT_LENGTH]
        if len(content) > self.MAX_CONTENT_LENGTH:
            logger.warning(f"Content truncated for user {self.user_id}: {len(content)} -> {self.MAX_CONTENT_LENGTH}")
        
        message = {
            'role': role,
            'content': truncated_content,
            'timestamp': datetime.now().isoformat()
        }
        
        self.history.append(message)
        
        # –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–ê–Ø –æ—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏
        if len(self.history) > self.MAX_HISTORY_SIZE:
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å
            removed_count = len(self.history) - self.MAX_HISTORY_SIZE
            removed_messages = self.history[:-self.MAX_HISTORY_SIZE]
            self.history = self.history[-self.MAX_HISTORY_SIZE:]
            
            # –Ø–≤–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏
            del removed_messages
            gc.collect()
            
            logger.debug(f"Memory cleanup: removed {removed_count} old messages for user {self.user_id}")
    
    def update_activity(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"""
        self.last_activity = datetime.now().isoformat()

class StateManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–æ—Å—Ç–æ—è–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.
    –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
    - –ê—Ç–æ–º–∞—Ä–Ω–∞—è –∑–∞–ø–∏—Å—å –¥–∞–Ω–Ω—ã—Ö
    - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ I/O
    - –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
    - –ù–û–í–û–ï: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
    """
    
    def __init__(self, data_file: str = 'data/users.json'):
        self.data_file = data_file
        self.users: Dict[int, UserState] = {}
        self._lock = asyncio.Lock()
        self._initialized = False
        
        # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
        os.makedirs(os.path.dirname(data_file), exist_ok=True)
        
        # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        self._cleanup_old_temp_files()
        
        # –ü–æ–ø—ã—Ç–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        self._sync_load_data()
    
    def _cleanup_old_temp_files(self):
        """
        –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤.
        –£–¥–∞–ª—è–µ—Ç –≤—Å–µ .tmp —Ñ–∞–π–ª—ã —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –¥–∞–Ω–Ω—ã–º —Ñ–∞–π–ª–æ–º –¥–∞–Ω–Ω—ã—Ö.
        """
        try:
            # –ò—â–µ–º –≤—Å–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è —ç—Ç–æ–≥–æ data_file
            pattern = f"{self.data_file}.tmp.*"
            temp_files = glob.glob(pattern)
            
            cleaned_count = 0
            for temp_file in temp_files:
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ñ–∞–π–ª –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∏ —Å—Ç–∞—Ä—ã–π
                    if os.path.exists(temp_file):
                        # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª—ã —Å—Ç–∞—Ä—à–µ 1 –º–∏–Ω—É—Ç—ã (—á—Ç–æ–±—ã –Ω–µ —É–¥–∞–ª–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ)
                        file_age = os.path.getmtime(temp_file)
                        current_time = datetime.now().timestamp()
                        
                        if current_time - file_age > 60:  # 60 —Å–µ–∫—É–Ω–¥
                            os.remove(temp_file)
                            cleaned_count += 1
                            logger.debug(f"Cleaned up old temp file: {temp_file}")
                        
                except Exception as cleanup_error:
                    logger.warning(f"Failed to cleanup temp file {temp_file}: {cleanup_error}")
            
            if cleaned_count > 0:
                logger.info(f"üßπ Startup cleanup: removed {cleaned_count} old temporary files")
            
        except Exception as e:
            logger.warning(f"Failed to cleanup old temp files: {e}")
    
    def _sync_load_data(self):
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏"""
        try:
            try:
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                for user_id_str, user_data in data.items():
                    user_id = int(user_id_str)
                    self.users[user_id] = UserState.from_dict(user_data)
                
                logger.info(f"Loaded {len(self.users)} users from {self.data_file}")
                
            except FileNotFoundError:
                logger.info(f"Data file {self.data_file} not found, starting with empty state")
                self.users = {}
        except Exception as e:
            logger.error(f"Error loading user data: {str(e)}", exc_info=True)
            self.users = {}
        
        self._initialized = True
    
    async def ensure_initialized(self):
        """–ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã (–¥–ª—è async –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞)"""
        if not self._initialized:
            await self.load_data()
    
    async def load_data(self):
        """
        –ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ —Ñ–∞–π–ª–∞ (async –≤–µ—Ä—Å–∏—è).
        –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π I/O.
        """
        try:
            async with self._lock:
                try:
                    # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ —á—Ç–µ–Ω–∏–µ
                    try:
                        import aiofiles
                        async with aiofiles.open(self.data_file, 'r', encoding='utf-8') as f:
                            content = await f.read()
                            data = json.loads(content)
                    except ImportError:
                        # Fallback –Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Ä–µ–∂–∏–º –µ—Å–ª–∏ aiofiles –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                        logger.warning("aiofiles not available, using sync I/O")
                        with open(self.data_file, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                    
                    for user_id_str, user_data in data.items():
                        user_id = int(user_id_str)
                        self.users[user_id] = UserState.from_dict(user_data)
                    
                    logger.info(f"Async loaded {len(self.users)} users from {self.data_file}")
                    
                except FileNotFoundError:
                    logger.info(f"Data file {self.data_file} not found, starting with empty state")
                    self.users = {}
                    
                self._initialized = True
                    
        except Exception as e:
            logger.error(f"Error loading user data: {str(e)}", exc_info=True)
            self.users = {}
    
    async def save_data(self):
        """
        –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ê—Ç–æ–º–∞—Ä–Ω–∞—è –∑–∞–ø–∏—Å—å –¥–∞–Ω–Ω—ã—Ö.
        –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä—Ä—É–ø—Ü–∏—é —Ñ–∞–π–ª–æ–≤ –ø—Ä–∏ —Å–±–æ—è—Ö.
        –û–ë–ù–û–í–õ–ï–ù–û: –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤.
        """
        temp_file = None
        try:
            async with self._lock:
                # –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –ó–ê–©–ò–¢–ê: –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –ø–µ—Ä–µ–¥ –∑–∞–ø–∏—Å—å—é
                self._cleanup_old_temp_files()
                
                # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏
                data = {}
                for user_id, user_state in self.users.items():
                    data[str(user_id)] = user_state.to_dict()
                
                # –ê–¢–û–ú–ê–†–ù–ê–Ø –ó–ê–ü–ò–°–¨: –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                temp_file = f"{self.data_file}.tmp.{os.getpid()}.{int(datetime.now().timestamp())}"
                
                try:
                    import aiofiles
                    # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –∑–∞–ø–∏—Å—å
                    async with aiofiles.open(temp_file, 'w', encoding='utf-8') as f:
                        await f.write(json.dumps(data, ensure_ascii=False, indent=2))
                except ImportError:
                    # Fallback –Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –∑–∞–ø–∏—Å—å
                    with open(temp_file, 'w', encoding='utf-8') as f:
                        json.dump(data, f, ensure_ascii=False, indent=2)
                
                # –ê—Ç–æ–º–∞—Ä–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
                shutil.move(temp_file, self.data_file)
                temp_file = None  # –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω
                
                logger.debug(f"‚úÖ Atomically saved {len(self.users)} users to {self.data_file}")
                
        except Exception as e:
            logger.error(f"üö® CRITICAL: Error saving user data: {str(e)}", exc_info=True)
            
            # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
            if temp_file and os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                    logger.debug(f"Cleaned up temporary file: {temp_file}")
                except Exception as cleanup_error:
                    logger.error(f"Failed to cleanup temp file: {cleanup_error}")
            
            # –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—ã—à–µ—Å—Ç–æ—è—â–µ–≥–æ –∫–æ–¥–∞
            raise
    
    def get_user(self, user_id: int) -> UserState:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"""
        if user_id not in self.users:
            self.users[user_id] = UserState(user_id=user_id)
            logger.info(f"Created new user state for {user_id}")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        self.users[user_id].last_activity = datetime.now().isoformat()
        
        return self.users[user_id]
    
    def add_to_history(self, user_id: int, role: str, content: str):
        """
        –î–æ–±–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —É–ª—É—á—à–µ–Ω–Ω—ã–π memory management.
        """
        user = self.get_user(user_id)
        user.add_message_to_history(role, content)
        
        logger.debug(f"Added message to history for user {user_id}: {role}")
    
    def get_user_history(self, user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        user = self.get_user(user_id)
        return user.history[-limit:] if limit > 0 else user.history
    
    def get_user_count(self) -> int:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        return len(self.users)
    
    def get_active_users(self, hours: int = 24) -> List[UserState]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∑–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è"""
        from datetime import timedelta
        
        cutoff_time = datetime.now() - timedelta(hours=hours)
        active_users = []
        
        for user in self.users.values():
            try:
                last_activity = datetime.fromisoformat(user.last_activity)
                if last_activity > cutoff_time:
                    active_users.append(user)
            except (ValueError, TypeError):
                # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏
                continue
        
        return active_users
    
    async def load_prompt(self, prompt_name: str) -> Optional[str]:
        """
        –ó–∞–≥—Ä—É–∂–∞–µ—Ç –ø—Ä–æ–º–ø—Ç –∏–∑ —Ñ–∞–π–ª–∞ –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.
        –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è.
        """
        try:
            # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é prompts –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
            prompts_dir = 'prompts'
            os.makedirs(prompts_dir, exist_ok=True)
            
            prompt_file = f"{prompts_dir}/{prompt_name}.txt"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
            if not os.path.exists(prompt_file):
                logger.debug(f"Prompt file not found: {prompt_file}")
                return None
            
            # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ —á—Ç–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Ñ–∞–π–ª–∞
            try:
                import aiofiles
                async with aiofiles.open(prompt_file, 'r', encoding='utf-8') as f:
                    content = await f.read()
            except ImportError:
                # Fallback –Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ —á—Ç–µ–Ω–∏–µ
                with open(prompt_file, 'r', encoding='utf-8') as f:
                    content = f.read()
            
            content = content.strip()
            
            if content:
                logger.debug(f"Loaded prompt: {prompt_name}")
                return content
            else:
                logger.warning(f"Empty prompt file: {prompt_file}")
                return None
                
        except Exception as e:
            logger.error(f"Error loading prompt {prompt_name}: {str(e)}", exc_info=True)
            return None
    
    def save_user(self, user_id: int, user_state: UserState):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        self.users[user_id] = user_state
        logger.debug(f"Updated user state for {user_id}")
    
    def cleanup_memory(self):
        """
        –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏.
        –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è memory leaks.
        """
        logger.debug("Starting memory cleanup...")
        
        cleaned_users = 0
        for user_state in self.users.values():
            if len(user_state.history) > user_state.MAX_HISTORY_SIZE:
                old_size = len(user_state.history)
                user_state.history = user_state.history[-user_state.MAX_HISTORY_SIZE:]
                cleaned_users += 1
                logger.debug(f"Cleaned history for user {user_state.user_id}: {old_size} -> {len(user_state.history)}")
        
        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ –º—É—Å–æ—Ä–∞
        gc.collect()
        
        logger.info(f"Memory cleanup completed: {cleaned_users} users cleaned")
        
    async def get_system_stats(self) -> Dict[str, Any]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∏—Å—Ç–µ–º—ã"""
        import psutil
        
        return {
            "users_count": len(self.users),
            "memory_usage_mb": psutil.Process().memory_info().rss / 1024 / 1024,
            "active_users_24h": len(self.get_active_users(24)),
            "data_file_size_kb": os.path.getsize(self.data_file) / 1024 if os.path.exists(self.data_file) else 0,
            "total_messages": sum(len(user.history) for user in self.users.values())
        }

    def force_cleanup_temp_files(self):
        """
        –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤.
        –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ emergency —Å–ª—É—á–∞—è—Ö.
        """
        try:
            pattern = f"{self.data_file}.tmp.*"
            temp_files = glob.glob(pattern)
            
            cleaned_count = 0
            for temp_file in temp_files:
                try:
                    if os.path.exists(temp_file):
                        os.remove(temp_file)
                        cleaned_count += 1
                        logger.debug(f"Force cleaned temp file: {temp_file}")
                except Exception as cleanup_error:
                    logger.error(f"Failed to force cleanup temp file {temp_file}: {cleanup_error}")
            
            if cleaned_count > 0:
                logger.info(f"üîß Force cleanup: removed {cleaned_count} temporary files")
            
            return cleaned_count
            
        except Exception as e:
            logger.error(f"Failed to force cleanup temp files: {e}")
            return 0 